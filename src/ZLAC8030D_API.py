
import ctypes
from enum import Enum
from dataclasses import dataclass
from logging import Logger, getLogger
from typing import Any, Dict, Generator, List, Tuple, Optional, Union

### Third Party ###
from minimalmodbus import MODE_RTU, Instrument, NoResponseError, ModbusException
from serial import Serial, PARITY_NONE


def bit_status(data=0x0, bit_position=0):
    return (data & (1 << bit_position)) != 0

class MotorSide(Enum):
    LEFT_SIDE = 1
    RIGHT_SIDE = 2 
class MotorErrorBitPositions(Enum):
    """
    Error codes, generated by the driver (Left: 0x20A5, Right: 0x20A6)
    """
    OVER_VOLTAGE = 1
    UNDER_VOLTAGE = 2 
    OVER_CURRENT = 3
    OVER_LOAD = 4
    CURRENT_OUT_OF_TOLERANCE = 5
    ENCODER_OUT_OF_TOLERANCE = 6
    VELOCITY_OUT_OF_TOLERANCE = 7
    REFERENCE_VOLTAGE_ERROR = 8
    EEPROM_ERROR = 9
    HALL_ERROR = 10
    MOTOR_OVER_TEMPERATURE = 11
    ENCODER_ERROR = 12
    DRIVER_OVER_TEMPERATURE = 13
    GIVEN_SPEED_ERROR = 14


class MotorStatusBitPositions(Enum):
    SHAFT_LOCK_LEFT = 6
    SHAFT_LOCK_RIGHT = 14
    EMERGENCY_STOP_LEFT = 7
    EMERGENCY_STOP_RIGHT = 15
    MOROT_RUNNING_LEFT = 0
    MOTOR_RUNNING_RIGHT = 8

class RS485Baud(Enum):
    B9600 = 6
    B19200 = 5
    B38400 = 4
    B57600 = 3
    B115200 = 2
    B128000 = 1


class CANBaud(Enum):
    B100 = 4
    B125 = 3
    B250 = 2
    B500 = 1
    B1000 = 0


class RPMSelector(Enum):
    _1_RPM = 0x1
    _1P2_RPM = 0x2
    _1P3_RPM = 0x3
    _1P4_RPM = 0x4
    _1P5_RPM = 0x5
    _1P6_RPM = 0x6
    _1P7_RPM = 0x7
    _1P8_RPM = 0x8
    _1P9_RPM = 0x9
    _1P10_RPM = 0xA

class ControlMode(Enum):
    UNDEFINED = 0
    POSITION_RELATIVE = 1
    POSITION_ABSOLUTE = 2
    VELOCITY = 3
    TORQUE = 4

class ControlWord(Enum):
    UNDEFINED = 0x0
    EMERGENCY_STOP = 0x05
    CLEAR_ERROR = 0x06
    STOP = 0x07
    ENABLE = 0x08
    START_SYNC = 0x10           # needed in position mode (Snc. mode)
    START_LEFT = 0x11           # needed in position mode
    START_RIGHT = 0x12          # needed in position mode

class SyncMode(Enum):
    SYNCHRONOUS_MODE = 0
    ASYNCHRONOUS_MODE = 1

class Direction(Enum):
    CW = 0
    CCW = 1

class ParkingMode(Enum):
    CLOSE = 0
    OPEN = 1

@dataclass
class MotorTemperature:
    LEFT_TEMPERATURE:float = 0
    RIGHT_TEMPERATURE:float = 0

    def __str__(self):
        return f"Left motor: {self.LEFT_TEMPERATURE}°C | Right Motor: {self.RIGHT_TEMPERATURE}°C"

@dataclass
class MotorErrors:
    OVER_VOLTAGE:bool = False
    UNDER_VOLTAGE:bool = False 
    OVER_CURRENT:bool = False
    OVER_LOAD:bool = False
    CURRENT_OUT_OF_TOLERANCE:bool = False
    ENCODER_OUT_OF_TOLERANCE:bool = False
    VELOCITY_OUT_OF_TOLERANCE:bool = False
    REFERENCE_VOLTAGE_ERROR:bool = False
    EEPROM_ERROR:bool = False
    HALL_ERROR:bool = False
    MOTOR_OVER_TEMPERATURE:bool = False
    ENCODER_ERROR:bool = False
    DRIVER_OVER_TEMPERATURE:bool = False
    GIVEN_SPEED_ERROR:bool = False

    def __str__(self):
        ret_string = ""
        if not (True in [self.OVER_VOLTAGE, self.UNDER_VOLTAGE, self.OVER_CURRENT, self.OVER_LOAD, self.CURRENT_OUT_OF_TOLERANCE, self.ENCODER_OUT_OF_TOLERANCE, self.VELOCITY_OUT_OF_TOLERANCE,
                    self.REFERENCE_VOLTAGE_ERROR, self.EEPROM_ERROR, self.HALL_ERROR, self.MOTOR_OVER_TEMPERATURE, self.ENCODER_ERROR, self.DRIVER_OVER_TEMPERATURE, self.GIVEN_SPEED_ERROR]):
            return f"No errors!"
        else:
            if self.OVER_VOLTAGE:
                ret_string += "Overvoltage, "
            if self.UNDER_VOLTAGE:
                ret_string += "Undervoltage, "
            if self.OVER_CURRENT:
                ret_string += "Overcurrent, "
            if self.OVER_LOAD:
                ret_string += "Overload, "
            if self.CURRENT_OUT_OF_TOLERANCE:
                ret_string += "Current out of tolerance, "
            if self.ENCODER_OUT_OF_TOLERANCE:
                ret_string += "Encoder out of tolerance, "
            if self.VELOCITY_OUT_OF_TOLERANCE:
                ret_string += "Velocity out of tolerance, "
            if self.REFERENCE_VOLTAGE_ERROR:
                ret_string += "Reference voltage error, "
            if self.EEPROM_ERROR:
                ret_string += "EEPROM error, "
            if self.HALL_ERROR:
                ret_string += "Hall sensor error, "
            if self.MOTOR_OVER_TEMPERATURE:
                ret_string += "Motor overtemperature, "
            if self.ENCODER_ERROR:
                ret_string += "Encoder error, "
            if self.DRIVER_OVER_TEMPERATURE:
                ret_string += "Driver overtemperature, "
            if self.GIVEN_SPEED_ERROR:
                ret_string += "Given speed error."
            return ret_string

@dataclass
class MotorStatus:
    SHAFT_LOCK_LEFT:bool = False
    SHAFT_LOCK_RIGHT:bool = False
    EMERGENCY_STOP_LEFT:bool = False
    EMERGENCY_STOP_RIGHT:bool = False
    ALARM_LEFT:bool = False
    ALARM_RIGHT:bool = False
    MOTOR_RUNNING_LEFT:bool = False
    MOTOR_RUNNING_RIGHT:bool = False
    
    def __str__(self):
        error_status_left = 'Shaft lock' if self.SHAFT_LOCK_LEFT and not self.EMERGENCY_STOP_LEFT else ('Emmergency stop' if not self.SHAFT_LOCK_LEFT and self.EMERGENCY_STOP_LEFT else ('Alarm' if self.SHAFT_LOCK_LEFT and self.EMERGENCY_STOP_LEFT else ''))
        error_status_right = 'Shaft lock' if self.SHAFT_LOCK_RIGHT and not self.EMERGENCY_STOP_RIGHT else ('Emmergency stop' if not self.SHAFT_LOCK_RIGHT and self.EMERGENCY_STOP_RIGHT else ('Alarm' if self.SHAFT_LOCK_LEFT and self.EMERGENCY_STOP_RIGHT else ''))
        return f"Left motor {'runs' if self.MOTOR_RUNNING_LEFT else 'stands'} - {error_status_left} | Right Motor {'runs' if self.MOTOR_RUNNING_LEFT else 'stands'} - {error_status_right}"

class ZLA8030D(Instrument):
    """Base class for driver.

    Parameters
    ----------
    portname : Union[str, Serial]
        Serial port path name.
    slave_address : int
        Slave address.
    baudrate : int, optional
        Baudrate, by default 57600
    logger : Optional[Logger]
        Logger object, root logger by default
    """

    ### ModbusRTU Commands ###
    _READ_COIL = 0x01
    """Modbus RTU command for reading coil"""
    _READ_INPUT = 0x02
    """Modbus RTU command for reading input"""
    _READ_HOLDING_REGISTER = 0x03
    """Modbus RTU command for reading holding register"""
    _READ_INPUT_REGISTER = 0x04
    """Modbus RTU command for reading input register"""
    _WRITE_COIL = 0x05
    """Modbus RTU command for writing coil"""
    _WRITE_HOLDING_REGISTER = 0x06
    """Modbus RTU command for writing holding register"""

    ### ERROR CODES ###
    _CODE_OK = 0
    _CODE_ERROR = 5
    _CODE_ILLEGAL_FUNCTION = 1
    _CODE_ILLEGAL_DATA_ADDRESS = 2
    _CODE_ILLEGAL_DATA_VALUE = 3
    _CODE_SLAVE_DEVICE_FAILURE = 4

    ### INPUT REGISTERS ### [READ ONLY]
    _INPUT_REGISTER_STATUS = 0x20A2
    """Driver controls motor movement: Left: bit7-bit6, Right: bit15-bit14:
            00 00:  Shaft release 
            00 40:  Shaft lock 
            00 80:  Emergency stop 
            00 C0:  Alarm

        Motor running status: Left: bit0, Right: bit8 
            0: Stop
            1: Run
    """
    _INPUT_REGISTER_DRIVER_TEMPERATURE = 0x20B0
    """I16 (SIGNED INT). Unit: 0.1°C; Range:-550~1200."""
    _INPUT_REGISTER_MOTOR_TEMPERATURE = 0x20A4
    """Unit: 1°C, Range:-55~120, Left: 8-15bits, Right: 0-7bits"""
    _INPUT_REGISTER_MOTOR_ERROR_CODE_LEFT = 0x20A5
    _INPUT_REGISTER_MOTOR_ERROR_CODE_RIGHT = 0x20A6
    """Driver error conditions defined by manufacturer.
            0b  0000    0000    0000    0000
                                           |-> Bit0: Overvoltage
                                          |-> Bit1: Undervoltage
                                         |-> Bit2: Overcurrent
                                        |-> Bit3: Overload
                                      
                                   |-> Bit4: Current out of tolerance(reserved)
                                  |-> Bit5: Encoder out of tolerance
                                 |-> Bit6: Velocity out of tolerance(reserved)
                                |-> Bit7: Reference voltage error
                          
                           |-> Bit8: EEPROM error
                          |-> Bit9: Hall error
                         |-> Bit10: Motor temperature over temperature
                        |-> Bit11: Encoder error
                
                   |-> Bit12: High driver temperature
                  |-> Bit13: Speed setting error(the given speed cannot exceedthe rated speed)
                 |-> Bit14: Reserved
                |-> Bit15: Reserved
    """
    _INPUT_REGISTER_MOTOR_ACTUAL_VELOCITY_LEFT = 0x20AB
    _INPUT_REGISTER_MOTOR_ACTUAL_VELOCITY_RIGHT = 0x20AC
    """I16 (SIGNED INT). Actual velocity. Unit: 0.1RPM"""
    _INPUT_REGISTER_MOTOR_ACTUAL_TORQUE_LEFT = 0x20AD
    _INPUT_REGISTER_MOTOR_ACTUAL_TORQUE_RIGHT = 0x20AE
    """I16 (SIGNED INT). Actual torque. Unit: 0.1A"""

    ### HOLDING REGISTERS ###
# DRIVER PARAMETER
    _HOLDING_REGISTER_COMMUNICATION_OFFLINE_TIME = 0x2000
    """Driver and host communication offline time setting. Unit: ms, Range: 0-32767, Default: 0"""
    _HOLDING_REGISTER_RESTORE_FACTORY_SETTINGS = 0x2009
    """If value 1, restore factory settings."""
    _HOLDING_REGISTER_WRITE_TO_EEPROM = 0x2010
    """Whether the value of the communication write function codeis updatedtothe EEPROM. 0: Invalid, 1: Store parameters have RW attribution to EEPROM"""

    _HOLDING_REGISTER_RS485_NODE_ID = 0x2001
    """Slave address. Range 1-127, Default: 1"""
    _HOLDING_REGISTER_RS485_BAUD = 0x2002
    """RS485 BaudRate. Values: [6-9600, 5-19200, 4-38400, 3-57600, 2-115200, 1-128000], Default: 2"""

    _HOLDING_REGISTER_CAN_NODE_ID = 0x200A
    """Slave address. Range 1-127, Default: 1"""
    _HOLDING_REGISTER_CAN_BAUD = 0x200B
    """CAN BaudRate. Values: [4-100, 3-125, 2-250, 1-500, 0-1000], Default: 1"""


    _HOLDING_REGISTER_INPUT_SIGNAL_STATUS = 0x2003
    """2 input signal level status Bit0-Bit1: X0-X1 input level status. Read only"""
    _HOLDING_REGISTER_OUTPUT_SIGNAL_STATUS = 0x2004
    """2 output signal level status. Bit0: Y1 output status; Bit1-Bit2: B0-B1 output status. Read only"""
    _HOLDING_REGISTER_SHAFT_STATE_AFTER_POWER_ON = 0x2007
    """0: Not enabled, not lock shaft; 1: Not enabled, lock shaft;"""
    _HOLDING_REGISTER_MAX_MOTOR_SPEED = 0x2008
    """Motor maximum speed. Unit: r/min, Range: 1-1000r/min, Default: 300"""
    
    _HOLDING_REGISTER_PARKING_MODE = 0x200C
    """0: Close, 1: Open. Defaul: 0"""
    _HOLDING_REGISTER_CONTROL_MODE = 0x200D
    """0: Undefined, 1: Position mode (Relative), 2: Position mode (Absolute), 3: Velocity mode, 4: Torque mode. Default: 0"""
    _HOLDING_REGISTER_CONTROL_WORD = 0x200E
    """ 0x00:   Undefined
        0x05:   Emergency stop
        0x06:   Clear error
        0x07:   Stop
        0x08:   Enable
        0x10:   Start(Synchronous)(needed in position mode)
        0x11:   Start(Left) (needed in position mode)
        0x12:   Start(Right) (needed in position mode)
    """
    _HOLDING_REGISTER_ENABLE_ASYNC_MODE = 0x200F
    """0: Synchronous mode, 1: Asynchronous mode. Default: 0"""
    _HOLDING_REGISTER_QUICK_STOP_MODE = 0x2011
    """How driver process when receive quick stop command. 5: Stop, 6: Quick stop (with deceleration time), 7: Quick stop (without deceleration time). Default: 5"""
    _HOLDING_REGISTER_CLOSE_OPERATION_MODE = 0x2012
    """How driver process when receive stop command. 0: Invalid, 1: Stop normally, switch to “ready to switch on” state. Default: 1"""
    _HOLDING_REGISTER_DISABLE_CONTROL_MODE = 0x2013
    """How driver process when receive disable command. 0: Invalid, 1: Stop (switch to “switch on” status). Default: 1"""
    _HOLDING_REGISTER_HALT_CONTROL_MODE = 0x2014
    """How driver process when receive Halt command. 1: Stop (operation enabled), 2: Quick stop with deceleration time (operation enable), 3: Quick stop without deceleration time (operation enable). Default: 1"""

    _HOLDING_REGISTER_INPUT_DEFAULT_LEVEL = 0x2016
    """Bit0: Input terminal X0, Bit1: Input terminal X1, Bit2: ADInput, Bit3-Bit5: reserved. 0: Default, 1: Reverse. The driver defaults to the input terminal level rising edge or high level active."""
    _HOLDING_REGISTER_X0_MODE = 0x2017
    """Input terminal X0 terminal function selection. 0: None, 1-8: NC, 9: Emergency STOP"""
    _HOLDING_REGISTER_X1_MODE = 0x2018
    """Input terminal X1 terminal function selection. 0: None, 1-8: NC, 9: Emergency STOP"""

    _HOLDING_REGISTER_OUTPUT_DEFAULT_LEVEL = 0x2019
    """Bit0: Output terminal Y1, Bit1: Output terminal B0, Bit2: Output terminal B1. 0: Default, 1: Reverse. The driver defaults to the input terminal level rising edge or high level active."""
    _HOLDING_REGISTER_B0_MODE = 0x201A
    """Output terminal B0 terminal function selection. 0: Open brake, 1: Close brake"""
    _HOLDING_REGISTER_B1_MODE = 0x201B
    """Output terminal B1 terminal function selection. 0: Open brake, 1: Close brake"""
    _HOLDING_REGISTER_Y1_MODE = 0x201B
    """Output terminal Y1 terminal function selection. 0: Undefined, 1: Alarm signal, 2: Drive status, Target position reached signal"""

    _HOLDING_REGISTER_DRIVER_TEMP_PROTECTION_THRESHOLD = 0x201E
    """Unit 0.1°C; Range: 0-1200. Defaut: 800"""
    _HOLDING_REGISTER_SPEED_RESOLUTION = 0x2022
    """1: 1 RPM, 2: 0.5 RPM, 3: 1/3 RPM 4: 0.25 RPM, 5: 0.2 RPM, 6: 1/6 RPM, 7: 1/7 RPM, 8: 0.125 RPM, 9: 1/9 RPM, A: 0.1RPM. Default: 1"""
    
    _HOLDING_REGISTER_REGEN_RES_VALUE = 0x2023
    """Regen resistance value. Unit 0.1Ω, Range 0-1000 (*0.1)"""
    _HOLDING_REGISTER_REGEN_RES_POWER = 0x2024
    """Regen resistance power. Unit W, Range 0-1000"""
    _HOLDING_REGISTER_REGEN_OPENING_VOLTAGE = 0x2025
    """Regen opening voltage . Unit 0.1V, Range 240-750 (*0.1). Default: 700"""
    _HOLDING_REGISTER_REGEN_CLOSE_VOLTAGE = 0x2026
    """Regen close voltage . Unit 0.1V, Range 240-750 (*0.1). Default: 620"""
    _HOLDING_REGISTER_REGEN_FUNC_CONTROL = 0x2027
    """Regen function control. Brake open/close. 0: close, 1: open. Default: 1"""

    _HOLDING_REGISTER_SPEED_EXCEEDS_TOLERANCE = 0x2028
    """0: close, 1: open. Default: 1"""
    _HOLDING_REGISTER_DEFAULT_DIRECTION = 0x2029
    """0: CW, 1: CCW. Default: 0"""

# CONTROL PARAMETER
    _HOLDING_REGISTER_S_SHAPE_ACCELERATION_LEFT = 0x2080
    _HOLDING_REGISTER_S_SHAPE_ACCELERATION_RIGHT = 0x2081
    _HOLDING_REGISTER_S_SHAPE_DECELERATION_LEFT = 0x2082
    _HOLDING_REGISTER_S_SHAPE_DECELERATION_RIGHT = 0x2083
    """Acceleration/Deceleration time Range: 0-32767ms. Default: 10"""
    _HOLDING_REGISTER_QUICK_STOP_DECELERATION_LEFT = 0x2084
    _HOLDING_REGISTER_QUICK_STOP_DECELERATION_RIGHT = 0x2085
    """Deceleration time Range: 0-32767ms. Default: 10"""

    _HOLDING_REGISTER_TARGET_VELOCITY_LEFT = 0x2088
    _HOLDING_REGISTER_TARGET_VELOCITY_RIGHT = 0x2089
    """Integer16 (SIGNED). Target velocity in velocity mode. Range: -3000 - 3000 RPM. Default: 0"""

    ### Bits ###
    _HIGH = 0x01
    _LOW = 0x00

    def __init__(
        self,
        port: Union[str, Serial],
        slave_address: int,
        baudrate: int = 115200,
        logger: Optional[Logger] = None,
    ):
        super(ZLA8030D, self).__init__(
            port=port,
            slaveaddress=slave_address,
            mode=MODE_RTU
        )
        ### Init ###
        self._logger = logger if logger is not None else getLogger()
        self._catch_exceptions = True

        ### Config instrument ###
        self.serial.baudrate = baudrate  # bps
        self.serial.bytesize = 8
        self.serial.parity = PARITY_NONE
        self.serial.stopbits = 1
        self.serial.timeout = 0.2  # seconds

    def write_eeprom(self):
        """
        After this command, the new settings will be stored in EEPROM!
        """
        ret_code = self._write_holding_register(registeraddress=self._HOLDING_REGISTER_WRITE_TO_EEPROM, value=1)
        
        return ret_code

    def motor_errors(self, side=MotorSide.LEFT_SIDE) -> MotorErrors:
        """Motor error status. 

        Returns
        -------
        info : MotorErrors

        """
        if side == MotorSide.LEFT_SIDE:
            ret_val = self._read_holding_register(registeraddress=self._INPUT_REGISTER_MOTOR_ERROR_CODE_LEFT)
        elif side == MotorSide.RIGHT_SIDE:
            ret_val = self._read_holding_register(registeraddress=self._INPUT_REGISTER_MOTOR_ERROR_CODE_RIGHT)
        else:
            self._logger.error(f"Unknown motor side parameter: {side}")
            return MotorErrors()
        
        motor_errors = MotorErrors(
            OVER_VOLTAGE = bit_status(data=ret_val, bit_position=MotorErrorBitPositions.OVER_VOLTAGE.value),
            UNDER_VOLTAGE = bit_status(data=ret_val, bit_position=MotorErrorBitPositions.UNDER_VOLTAGE.value),
            OVER_CURRENT = bit_status(data=ret_val, bit_position=MotorErrorBitPositions.OVER_CURRENT.value),
            OVER_LOAD = bit_status(data=ret_val, bit_position=MotorErrorBitPositions.OVER_LOAD.value),
            CURRENT_OUT_OF_TOLERANCE = bit_status(data=ret_val, bit_position=MotorErrorBitPositions.CURRENT_OUT_OF_TOLERANCE.value),
            ENCODER_OUT_OF_TOLERANCE = bit_status(data=ret_val, bit_position=MotorErrorBitPositions.ENCODER_OUT_OF_TOLERANCE.value),
            VELOCITY_OUT_OF_TOLERANCE = bit_status(data=ret_val, bit_position=MotorErrorBitPositions.VELOCITY_OUT_OF_TOLERANCE.value),
            REFERENCE_VOLTAGE_ERROR = bit_status(data=ret_val, bit_position=MotorErrorBitPositions.REFERENCE_VOLTAGE_ERROR.value),
            EEPROM_ERROR = bit_status(data=ret_val, bit_position=MotorErrorBitPositions.EEPROM_ERROR.value),
            HALL_ERROR = bit_status(data=ret_val, bit_position=MotorErrorBitPositions.HALL_ERROR.value),
            MOTOR_OVER_TEMPERATURE = bit_status(data=ret_val, bit_position=MotorErrorBitPositions.MOTOR_OVER_TEMPERATURE.value),
            ENCODER_ERROR = bit_status(data=ret_val, bit_position=MotorErrorBitPositions.ENCODER_ERROR.value),
            DRIVER_OVER_TEMPERATURE = bit_status(data=ret_val, bit_position=MotorErrorBitPositions.DRIVER_OVER_TEMPERATURE.value),
            GIVEN_SPEED_ERROR = bit_status(data=ret_val, bit_position=MotorErrorBitPositions.GIVEN_SPEED_ERROR.value),
        )
        
        return motor_errors
    
    @property
    def motor_errors_left(self) -> MotorErrors:
        return self.motor_errors(side=MotorSide.LEFT_SIDE)

    @property
    def motor_errors_right(self) -> MotorErrors:
        return self.motor_errors(side=MotorSide.RIGHT_SIDE)

    @property
    def motor_temperature(self) -> MotorTemperature:
        """Left and Right motor temperature in °C.
        Range : -55°C - 120°C

        Returns
        -------
        info : MotorTemperature

        """
        TemperatureOffset = -55     # °C
        ret_val = self._read_holding_register(registeraddress=self._INPUT_REGISTER_MOTOR_TEMPERATURE)
        motor_temperature = MotorTemperature(
            LEFT_TEMPERATURE = ctypes.c_int8((ret_val & 0xFF00) >> 8).value,
            RIGHT_TEMPERATURE = ctypes.c_int8(ret_val & 0x00FF).value,
        )
        
        return motor_temperature
    
    @property
    def motor_status(self) -> MotorStatus:
        """Motor status.

        Returns
        -------
        info : MotorStatus
        """
        ret_val = self._read_holding_register(registeraddress=self._INPUT_REGISTER_STATUS)
        motor_status = MotorStatus(
            SHAFT_LOCK_LEFT = bit_status(data=ret_val, bit_position=MotorStatusBitPositions.SHAFT_LOCK_LEFT.value),
            SHAFT_LOCK_RIGHT = bit_status(data=ret_val, bit_position=MotorStatusBitPositions.SHAFT_LOCK_RIGHT.value),
            EMERGENCY_STOP_LEFT = bit_status(data=ret_val, bit_position=MotorStatusBitPositions.EMERGENCY_STOP_LEFT.value),
            EMERGENCY_STOP_RIGHT = bit_status(data=ret_val, bit_position=MotorStatusBitPositions.EMERGENCY_STOP_RIGHT.value),
            ALARM_LEFT = bit_status(data=ret_val, bit_position=MotorStatusBitPositions.EMERGENCY_STOP_LEFT.value) & bit_status(data=ret_val, bit_position=MotorStatusBitPositions.SHAFT_LOCK_LEFT.value),
            ALARM_RIGHT = bit_status(data=ret_val, bit_position=MotorStatusBitPositions.EMERGENCY_STOP_RIGHT.value) & bit_status(data=ret_val, bit_position=MotorStatusBitPositions.SHAFT_LOCK_RIGHT.value),
            MOTOR_RUNNING_LEFT = bit_status(data=ret_val, bit_position=MotorStatusBitPositions.MOROT_RUNNING_LEFT.value),
            MOTOR_RUNNING_RIGHT = bit_status(data=ret_val, bit_position=MotorStatusBitPositions.MOTOR_RUNNING_RIGHT.value),
        )

        return motor_status
    
    @property
    def driver_temperature(self) -> float:
        """Driver temperature in °C.
        Range : -55°C - 120°C

        Returns
        -------
        info : MotorTemperature

        """
        ret_val = self._read_holding_register(registeraddress=self._INPUT_REGISTER_DRIVER_TEMPERATURE, signed=True)
        ret_val = ret_val / 10
        
        return ret_val

    @property
    def max_speed(self) -> int:
        """Motor maximum speed. 
        Unit: r/min, 
        Range: 1-1000r/min, 
        Default: 300,

        Returns
        -------
        speed : int
        """
        ret_val = self._read_holding_register(registeraddress=self._HOLDING_REGISTER_MAX_MOTOR_SPEED)
        return ret_val

    @max_speed.setter
    def max_speed(self, speed: int):
        """Motor maximum speed. 
        Unit: r/min, 
        Range: 1-1000r/min, 
        Default: 300,

        Parameters
        ----------
        speed : int

        Raises
        ------
        TypeError
            If speed arg is not int
        ValueError
            If speed is not included in ranges
        """
        if not isinstance(speed, int):
            raise TypeError(f"Invalid speed type expected int, not {type(speed)}")
        ret_code = self._CODE_OK

        if 1 <= speed <= 1000:
            ret_code = self._write_holding_register(registeraddress=self._HOLDING_REGISTER_MAX_MOTOR_SPEED, value=speed)
        else:
            raise ValueError(f"Speed {speed} RPM is not in range (1-1000RPM).")

        return ret_code
    
    @property
    def motor_speed_resolution(self) -> RPMSelector:
        """Speed resolution of setter. 
        
        Returns
        -------
        resolution : RPMSelector
        """
        ret_val = self._read_holding_register(registeraddress=self._HOLDING_REGISTER_SPEED_RESOLUTION)
        return RPMSelector(ret_val)
    
    @motor_speed_resolution.setter
    def motor_speed_resolution(self, resolution: RPMSelector):
        if not isinstance(resolution, RPMSelector):
            raise TypeError(f"Invalid resolution type expected RPMSelector Enum, not {type(resolution)}")
        ret_code = self._CODE_OK

        self._logger.warning(f"Resolution setter was not functioning during tests. Driver didnt write the new value into the EEPROM!")
        ret_code = self._write_holding_register(registeraddress=self._HOLDING_REGISTER_SPEED_RESOLUTION, value=resolution.value)
        return ret_code

    @property
    def parking_mode(self) -> ParkingMode:
        """Parking mode of the wheels. 
        0: Close
        1: Open
        
        Returns
        -------
        mode : ParkingMode
        """
        ret_val = self._read_holding_register(registeraddress=self._HOLDING_REGISTER_PARKING_MODE)
        return ParkingMode(ret_val)

    @parking_mode.setter
    def parking_mode(self, mode: ParkingMode):
        if not isinstance(mode, ParkingMode):
            raise TypeError(f"Invalid mode type expected ParkingMode Enum, not {type(mode)}")
        ret_code = self._CODE_OK

        ret_code = self._write_holding_register(registeraddress=self._HOLDING_REGISTER_PARKING_MODE, value=mode.value)
        return ret_code

    @property
    def control_mode(self) -> ControlMode:
        """Control mode of the wheels. 
        0: Unidentified
        1: Position mode (Relative)
        2: Position mode (Absolute)
        3: Velocity mode
        4: Torque mode 

        Returns
        -------
        mode : ControlMode
        """
        ret_val = self._read_holding_register(registeraddress=self._HOLDING_REGISTER_CONTROL_MODE)
        return ControlMode(ret_val)

    @control_mode.setter
    def control_mode(self, mode: ControlMode):
        """Control mode of the wheels. 
        0: Unidentified
        1: Position mode (Relative)
        2: Position mode (Absolute)
        3: Velocity mode
        4: Torque mode 

        Parameters
        ----------
        mode : ControlMode

        Raises
        ------
        TypeError
            If mode is not an Enum
        """
        if not isinstance(mode, ControlMode):
            raise TypeError(f"Invalid mode type expected ControlMode Enum, not {type(mode)}")
        ret_code = self._CODE_OK

        ret_code = self._write_holding_register(registeraddress=self._HOLDING_REGISTER_CONTROL_MODE, value=mode.value)
        return ret_code
    
    @property
    def control_word(self) -> ControlWord:
        """Control commands.
        
        Returns
        -------
        resolution : ControlWord
        """
        ret_val = self._read_holding_register(registeraddress=self._HOLDING_REGISTER_CONTROL_WORD)
     
        return ControlWord(ret_val)

    @control_word.setter
    def control_word(self, command: ControlWord):
        if not isinstance(command, ControlWord):
            raise TypeError(f"Invalid mode type expected ControlWord Enum, not {type(command)}")
        ret_code = self._CODE_OK

        ret_code = self._write_holding_register(registeraddress=self._HOLDING_REGISTER_CONTROL_WORD, value=command.value)
        return ret_code
    
    @property
    def direction(self) -> Direction:
        """Direction command.
        
        Returns
        -------
        resolution : ControlWord
        """
        ret_val = self._read_holding_register(registeraddress=self._HOLDING_REGISTER_DEFAULT_DIRECTION)
     
        return Direction(ret_val)

    @direction.setter
    def direction(self, direction: Direction):
        if not isinstance(direction, Direction):
            raise TypeError(f"Invalid mode type expected Direction Enum, not {type(direction)}")
        ret_code = self._CODE_OK

        ret_code = self._write_holding_register(registeraddress=self._HOLDING_REGISTER_DEFAULT_DIRECTION, value=direction.value)
        return ret_code

    @property
    def sync_mode(self) -> SyncMode:
        """Sync or Async mode selector of the wheels. 
        0: Synchronous mode
        1: Asynchronous mode
        Default: 0,

        Returns
        -------
        mode : SyncMode
        """
        ret_val = self._read_holding_register(registeraddress=self._HOLDING_REGISTER_ENABLE_ASYNC_MODE)
        return SyncMode(ret_val)

    @sync_mode.setter
    def sync_mode(self, mode: SyncMode):
        """Sync or Async mode selector of the wheels. 
        0: Synchronous mode
        1: Asynchronous mode
        Default: 0,

        Parameters
        ----------
        mode : SyncMode

        Raises
        ------
        TypeError
            If mode is not an Enum
        """
        if not isinstance(mode, SyncMode):
            raise TypeError(f"Invalid mode type expected SyncMode Enum, not {type(mode)}")
        ret_code = self._CODE_OK

        ret_code = self._write_holding_register(registeraddress=self._HOLDING_REGISTER_ENABLE_ASYNC_MODE, value=mode.value)
        return ret_code

    @property
    def speed_left(self):
        """Gets back the actual speed of the left motor. 
        
        Returns
        -------
        speed : signed int [RPM]
        """
        ret_val = self._read_holding_register(registeraddress=self._INPUT_REGISTER_MOTOR_ACTUAL_VELOCITY_LEFT)
        return ret_val

    @speed_left.setter
    def speed_left(self, speed: int):
        """Set the target velocity
        
        Parameters
        ----------
        speed : signed int RPM

        Raises
        ------
        TypeError
            If speed is not an int
        ValueError
            If speed is out of the available range (setted range not checked)
        """
        if not isinstance(speed, int):
            raise TypeError(f"Invalid speed type expected int, not {type(speed)}")
        if not (-3000 <= speed <= 3000):
            raise TypeError(f"Invalid speed. Out of range (-3000 <= speed <= 3000) - Instead: {speed}RPM")

        ret_code = self._CODE_OK

        ret_code = self._write_holding_register(registeraddress=self._HOLDING_REGISTER_TARGET_VELOCITY_LEFT, value=speed, signed=True)
        return ret_code
    
    @property
    def speed_right(self):
        """Gets back the actual speed of the right motor. 
        
        Returns
        -------
        speed : signed int [RPM]
        """
        ret_val = self._read_holding_register(registeraddress=self._INPUT_REGISTER_MOTOR_ACTUAL_VELOCITY_RIGHT)
        return ret_val

    @speed_right.setter
    def speed_right(self, speed: int):
        """Set the target velocity
        
        Parameters
        ----------
        speed : signed int RPM

        Raises
        ------
        TypeError
            If speed is not an int
        ValueError
            If speed is out of the available range (setted range not checked)
        """
        if not isinstance(speed, int):
            raise TypeError(f"Invalid speed type expected int, not {type(speed)}")
        if not (-3000 <= speed <= 3000):
            raise TypeError(f"Invalid speed. Out of range (-3000 <= speed <= 3000) - Instead: {speed}RPM")

        ret_code = self._CODE_OK

        ret_code = self._write_holding_register(registeraddress=self._HOLDING_REGISTER_TARGET_VELOCITY_RIGHT, value=speed, signed=True)
        return ret_code

    def speed_both(self, speed):
        self.write_registers(registeraddress=self._HOLDING_REGISTER_TARGET_VELOCITY_LEFT, values=[speed, speed])

    @property
    def catch_exceptions(self) -> bool:
        """
        If True all read and write functions will catch and log Exceptions and return an error code (while not stopping execution)
        If False read and write functions will throw Exceptions 
        """
        return self._catch_exceptions
    
    @catch_exceptions.setter
    def catch_exceptions(self, value:bool):
        self._catch_exceptions = value


    def handle_exceptions(method:callable):
        def wrapper(self:"ZLA8030D", *args, **kwargs):
            # Assuming registeraddress is the first argument
            if not self.catch_exceptions:
                ret = method(self, *args, **kwargs)
                # If it is a write() function, it will return None
                return ret if ret is not None else self._CODE_OK
            try:
                ret = method(self, *args, **kwargs)
                return ret if ret is not None else self._CODE_OK
            except NoResponseError:
                err_details = f"Exception while {method.__name__} {args[0] if len(args) > 0 else kwargs['registeraddress']} of device {self.address}"
                self._logger.exception(err_details)
            except IOError:
                err_details = f"Exception while {method.__name__} {args[0] if len(args) > 0 else kwargs['registeraddress']} of device {self.address}"
                self._logger.exception(err_details)
            return self._CODE_ERROR
        return wrapper


    @handle_exceptions
    def _read_coil(self, registeraddress: int) -> int:
        """Read Coil/Bit register

        Parameters
        ----------
        registeraddress : int
            Register address

        Returns
        -------
        int
            Data in register or _CODE_ERROR that indicates failed read
        """
        return self.read_bit(
            registeraddress=registeraddress,
            functioncode=self._READ_COIL,
        )  


    @handle_exceptions
    def _write_coil(self, registeraddress: int, value: int) -> int:
        """Write Coil/Bit register

        Parameters
        ----------
        registeraddress : int
            Register address
        value : int
            Value that is to be written in the register

        Returns
        -------
        int
            _CODE_OK or _CODE_ERROR that indicates failed read
        """
        return self.write_bit(
            registeraddress=registeraddress,
            value=value,
            functioncode=self._WRITE_COIL,
        )


    @handle_exceptions
    def _read_input(self, registeraddress: int) -> int:
        """Read Read-Only/Input Bit

        Parameters
        ----------
        registeraddress : int
            Register address

        Returns
        -------
        int
            Data in register or _CODE_ERROR that indicates failed read
        """
        return self.read_bit(
            registeraddress=registeraddress,
            functioncode=self._READ_INPUT,
        )


    @handle_exceptions
    def _read_input_register(
        self,
        registeraddress: int,
        number_of_decimals: int = 0,
    ) -> Union[int, float]:
        """Read Read-Only/Input Register

        Parameters
        ----------
        registeraddress : int
            Register address
        number_of_decimals : int, optional
            This arg indicates if return value should be divided by
            10, 100 or 1000 ... Number of decimals is the number of
            zeros after the number 1 in the above example, by default 0

        Returns
        -------
        Union[int, float]
            The value, which is read from the register
        """
        return self.read_register(
            registeraddress=registeraddress,
            number_of_decimals=number_of_decimals,
            functioncode=self._READ_INPUT_REGISTER,
        )


    @handle_exceptions
    def _read_holding_register(
        self,
        registeraddress: int,
        number_of_decimals: int = 0,
        signed: bool = False
    ) -> Union[int, float]:
        """Read Holding/Read-Write Register

        Parameters
        ----------
        registeraddress : int
            Register address
        number_of_decimals : int, optional
            This arg indicates if return value should be divided by
            10, 100 or 1000 ... Number of decimals is the number of
            zeros after the number 1 in the above example, by default 0

        Returns
        -------
        Union[int, float]
            The value, which is read from the register
        """
        return self.read_register(
            registeraddress=registeraddress,
            number_of_decimals=number_of_decimals,
            functioncode=self._READ_HOLDING_REGISTER,
            signed=signed
        )


    @handle_exceptions
    def _write_holding_register(
        self,
        registeraddress: int,
        value: Union[int, float],
        number_of_decimals: int = 0,
        signed: bool = False,
    ) -> int:
        """Write into Holding/Read-Write Register

        Parameters
        ----------
        registeraddress : int
            Register address
        value : Union[int, float]
            Input value, which is to be written into register
        number_of_decimals : int, optional
            This arg indicates if return value should be divided by
            10, 100 or 1000 ... Number of decimals is the number of
            zeros after the number 1 in the above example, by default 0
        signed : bool, optional
            If True -32,768 to 32,767 otherwise 0 to 65,535, by default False

        Returns
        -------
        int
            Errno that indicates if command was successful.
        """
        return self.write_register(
            registeraddress=registeraddress,
            value=value,
            number_of_decimals=number_of_decimals,
            functioncode=self._WRITE_HOLDING_REGISTER,
            signed=signed,
        )